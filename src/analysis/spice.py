"""SPICE circuit simulation using ngspice as the backend."""

from __future__ import annotations

import re
import subprocess
import tempfile
from pathlib import Path
from typing import Any

import numpy as np

from ..core.models import PCBDesign, Component, ComponentType
from ..core.config import SimulationConfig, SimulationResult, SimulationType


class SpiceSimulator:
    """Generate SPICE netlists and run simulations via ngspice."""

    NGSPICE_BIN = "ngspice"

    def generate_netlist(self, design: PCBDesign) -> str:
        """Convert a PCBDesign into a SPICE netlist string."""
        lines: list[str] = []
        lines.append(f"* PCB-SIM netlist for: {design.name}")
        lines.append(f"* Generated by pcb-sim-toolkit")
        lines.append("")

        # Emit each component
        for comp in design.components:
            line = self._component_to_spice(comp, design)
            if line:
                lines.append(line)

        lines.append("")
        return "\n".join(lines)

    def run(
        self,
        design: PCBDesign,
        stage: SimulationType,
        config: SimulationConfig,
    ) -> SimulationResult:
        netlist = self.generate_netlist(design)
        control = self._build_control_block(stage, config)
        full_netlist = netlist + "\n" + control + "\n.end\n"

        with tempfile.TemporaryDirectory(prefix="pcbsim_") as tmpdir:
            netlist_path = Path(tmpdir) / "circuit.cir"
            raw_path = Path(tmpdir) / "output.raw"
            log_path = Path(tmpdir) / "sim.log"

            netlist_path.write_text(full_netlist)

            # Write the netlist for debugging
            debug_out = config.output_dir / f"{stage.value}_netlist.cir"
            debug_out.parent.mkdir(parents=True, exist_ok=True)
            debug_out.write_text(full_netlist)

            try:
                proc = subprocess.run(
                    [self.NGSPICE_BIN, "-b", "-r", str(raw_path), str(netlist_path)],
                    capture_output=True,
                    text=True,
                    timeout=120,
                )
            except FileNotFoundError:
                return self._fallback_simulation(design, stage, config)

            log_path.write_text(proc.stdout + "\n" + proc.stderr)

            if proc.returncode != 0 and not raw_path.exists():
                return self._fallback_simulation(design, stage, config)

            data = self._parse_raw_output(raw_path) if raw_path.exists() else {}

        return SimulationResult(success=True, sim_type=stage, data=data)

    # -- internal helpers --

    def _component_to_spice(self, comp: Component, design: PCBDesign) -> str | None:
        """Map a PCB component to a SPICE declaration."""
        nodes = self._resolve_nodes(comp, design)
        prefix = comp.spice_prefix

        if comp.component_type in (
            ComponentType.RESISTOR,
            ComponentType.CAPACITOR,
            ComponentType.INDUCTOR,
        ):
            if len(nodes) < 2:
                return None
            return f"{prefix}{comp.reference} {nodes[0]} {nodes[1]} {comp.value}"

        if comp.component_type == ComponentType.DIODE:
            if len(nodes) < 2:
                return None
            model = comp.properties.get("model", "D1N4148")
            return f"{prefix}{comp.reference} {nodes[0]} {nodes[1]} {model}"

        if comp.component_type in (
            ComponentType.TRANSISTOR_NPN,
            ComponentType.TRANSISTOR_PNP,
        ):
            if len(nodes) < 3:
                return None
            model = comp.properties.get("model", "2N2222")
            return (
                f"{prefix}{comp.reference} "
                f"{nodes[0]} {nodes[1]} {nodes[2]} {model}"
            )

        if comp.component_type in (ComponentType.MOSFET_N, ComponentType.MOSFET_P):
            if len(nodes) < 3:
                return None
            model = comp.properties.get("model", "NMOS")
            # D G S
            return (
                f"M{comp.reference} "
                f"{nodes[0]} {nodes[1]} {nodes[2]} {nodes[2]} {model}"
            )

        if comp.component_type == ComponentType.VOLTAGE_SOURCE:
            if len(nodes) < 2:
                return None
            return f"V{comp.reference} {nodes[0]} {nodes[1]} {comp.value}"

        if comp.component_type == ComponentType.CURRENT_SOURCE:
            if len(nodes) < 2:
                return None
            return f"I{comp.reference} {nodes[0]} {nodes[1]} {comp.value}"

        return f"* Unsupported component: {comp.reference} ({comp.component_type})"

    @staticmethod
    def _resolve_nodes(comp: Component, design: PCBDesign) -> list[str]:
        """Find net names connected to each pad of a component."""
        nodes: list[str] = []
        for pad in comp.pads:
            node_name = "0"  # default to ground
            for net in design.nets:
                pad_ref = f"{comp.reference}.{pad.name}"
                if pad_ref in net.nodes:
                    node_name = net.name.replace("-", "_").replace(" ", "_")
                    break
            nodes.append(node_name)
        return nodes

    def _build_control_block(
        self, stage: SimulationType, config: SimulationConfig
    ) -> str:
        lines: list[str] = []
        lines.append(".control")

        if stage == SimulationType.SPICE_DC:
            lines.append("op")
            lines.append("print all")

        elif stage == SimulationType.SPICE_AC:
            fstart, fstop = config.frequency_range
            lines.append(f"ac dec 100 {fstart} {fstop}")
            lines.append("plot all")

        elif stage == SimulationType.SPICE_TRANSIENT:
            lines.append(f"tran {config.time_step} {config.duration}")
            lines.append("plot all")

        lines.append("write output.raw")
        lines.append("quit")
        lines.append(".endc")
        return "\n".join(lines)

    def _parse_raw_output(self, raw_path: Path) -> dict[str, Any]:
        """Parse ngspice binary raw file into numpy arrays."""
        data: dict[str, Any] = {}
        try:
            content = raw_path.read_text(errors="replace")
            variables: list[str] = []
            in_vars = False
            n_points = 0

            for line in content.splitlines():
                if line.startswith("No. Variables:"):
                    n_vars = int(line.split(":")[1].strip())
                elif line.startswith("No. Points:"):
                    n_points = int(line.split(":")[1].strip())
                elif line.strip() == "Variables:":
                    in_vars = True
                elif line.strip() == "Values:" or line.strip() == "Binary:":
                    in_vars = False
                elif in_vars:
                    parts = line.strip().split()
                    if len(parts) >= 2:
                        variables.append(parts[1])

            data["variables"] = variables
            data["n_points"] = n_points
        except Exception:
            data["parse_error"] = "Could not parse raw output"
        return data

    def _fallback_simulation(
        self,
        design: PCBDesign,
        stage: SimulationType,
        config: SimulationConfig,
    ) -> SimulationResult:
        """Run a built-in analytical simulation when ngspice is not available."""
        warnings = ["ngspice not found; using built-in analytical solver"]
        data: dict[str, Any] = {}

        if stage == SimulationType.SPICE_DC:
            data = self._dc_analysis(design)
        elif stage == SimulationType.SPICE_AC:
            data = self._ac_analysis(design, config)
        elif stage == SimulationType.SPICE_TRANSIENT:
            data = self._transient_analysis(design, config)

        return SimulationResult(
            success=True, sim_type=stage, data=data, warnings=warnings
        )

    def _dc_analysis(self, design: PCBDesign) -> dict[str, Any]:
        """Simple DC operating point estimation."""
        node_voltages: dict[str, float] = {"0": 0.0, "GND": 0.0}

        for comp in design.components:
            if comp.component_type == ComponentType.VOLTAGE_SOURCE:
                nodes = self._resolve_nodes(comp, design)
                try:
                    voltage = self._parse_value(comp.value)
                    if len(nodes) >= 2:
                        node_voltages[nodes[0]] = voltage
                except ValueError:
                    pass

        return {"node_voltages": node_voltages, "analysis": "dc_operating_point"}

    def _ac_analysis(
        self, design: PCBDesign, config: SimulationConfig
    ) -> dict[str, Any]:
        freqs = np.logspace(
            np.log10(config.frequency_range[0]),
            np.log10(config.frequency_range[1]),
            200,
        )
        # Estimate impedance vs frequency for RC/RL networks
        impedances: dict[str, Any] = {}
        for comp in design.components:
            if comp.component_type == ComponentType.CAPACITOR:
                c = self._parse_value(comp.value)
                z = 1.0 / (2 * np.pi * freqs * c)
                impedances[comp.reference] = {
                    "magnitude": z.tolist(),
                    "phase_deg": (-90.0 * np.ones_like(freqs)).tolist(),
                }
            elif comp.component_type == ComponentType.INDUCTOR:
                l_val = self._parse_value(comp.value)
                z = 2 * np.pi * freqs * l_val
                impedances[comp.reference] = {
                    "magnitude": z.tolist(),
                    "phase_deg": (90.0 * np.ones_like(freqs)).tolist(),
                }

        return {
            "frequencies": freqs.tolist(),
            "impedances": impedances,
            "analysis": "ac_sweep",
        }

    def _transient_analysis(
        self, design: PCBDesign, config: SimulationConfig
    ) -> dict[str, Any]:
        t = np.arange(0, config.duration, config.time_step)
        waveforms: dict[str, Any] = {}

        for comp in design.components:
            if comp.component_type == ComponentType.VOLTAGE_SOURCE:
                val = comp.value.strip().upper()
                if "SIN" in val:
                    # Parse SIN(offset amplitude freq)
                    match = re.search(
                        r"SIN\(\s*([\d.e+-]+)\s+([\d.e+-]+)\s+([\d.e+-]+)", val
                    )
                    if match:
                        offset = float(match.group(1))
                        amp = float(match.group(2))
                        freq = float(match.group(3))
                        waveforms[comp.reference] = (
                            offset + amp * np.sin(2 * np.pi * freq * t)
                        ).tolist()
                elif "PULSE" in val:
                    match = re.search(
                        r"PULSE\(\s*([\d.e+-]+)\s+([\d.e+-]+)", val
                    )
                    if match:
                        v1 = float(match.group(1))
                        v2 = float(match.group(2))
                        period = config.duration / 5
                        waveform = np.where(
                            (t % period) < (period / 2), v2, v1
                        )
                        waveforms[comp.reference] = waveform.tolist()
                else:
                    try:
                        dc = self._parse_value(val.replace("DC", "").strip())
                        waveforms[comp.reference] = (
                            dc * np.ones_like(t)
                        ).tolist()
                    except ValueError:
                        pass

        return {
            "time": t.tolist(),
            "waveforms": waveforms,
            "analysis": "transient",
        }

    @staticmethod
    def _parse_value(val_str: str) -> float:
        """Parse engineering notation like 10k, 4.7u, 100n, etc."""
        val_str = val_str.strip().upper()
        # Ordered longest-suffix-first to avoid partial matches (e.g. MEG vs G)
        multipliers = [
            ("MEG", 1e6),
            ("T", 1e12),
            ("G", 1e9),
            ("K", 1e3),
            ("M", 1e-3),
            ("U", 1e-6),
            ("N", 1e-9),
            ("P", 1e-12),
            ("F", 1e-15),
        ]
        for suffix, mult in multipliers:
            if val_str.endswith(suffix):
                return float(val_str[: -len(suffix)]) * mult
        return float(val_str)
